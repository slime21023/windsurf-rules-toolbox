<software_engineering_best_practices>

<requirements_engineering>
- 使用用戶故事（User Stories）或功能需求文檔（FRD）明確捕獲功能需求
- 採用 INVEST 原則編寫高質量用戶故事
- 使用驗收標準明確定義完成的定義
- 實施需求跟踪矩陣確保所有需求都被實現和測試
- 使用原型和線框圖幫助利益相關者可視化解決方案
- 定期進行需求審查會議
- 使用 MoSCoW 方法進行需求優先級排序
</requirements_engineering>

<software_architecture>
- 遵循關注點分離原則設計系統架構
- 採用領域驅動設計方法將業務領域映射到軟體架構
- 使用設計模式解決常見架構問題，但避免過度設計
- 遵循 SOLID 原則
- 評估微服務架構的成本效益
- 實施 API 優先設計
- 使用架構決策記錄文檔化重要決策
- 進行架構風險分析
</software_architecture>

<code_quality>
- 遵循一致的代碼風格指南，使用自動化工具強制執行
- 實施代碼審查流程
- 使用靜態代碼分析工具識別潛在問題
- 監控代碼複雜度
- 遵循 DRY 原則，但避免過早抽象
- 編寫自文檔化代碼，使用有意義的命名
- 遵循 KISS 原則
- 定期進行代碼重構
</code_quality>

<testing_strategy>
- 實施測試金字塔策略
- 採用 TDD 或 BDD 方法
- 使用模擬和存根隔離測試單元
- 實施自動化測試套件
- 監控代碼覆蓋率，但不以覆蓋率為唯一目標
- 進行性能測試、負載測試和壓力測試
- 實施安全測試
- 使用混沌工程原則測試系統彈性
</testing_strategy>

<version_control>
- 使用語義化版本控制進行版本編號
- 採用清晰的分支策略
- 使用描述性的提交消息
- 保持小型、頻繁的提交
- 使用拉取請求進行代碼審查
- 配置分支保護規則
- 使用標籤標記重要的發布版本
- 定期清理過時的分支和標籤
</version_control>

<ci_cd>
- 實施持續集成流程
- 採用持續部署或持續交付實踐
- 使用基礎設施即代碼管理基礎設施
- 實施環境一致性策略
- 使用特性標誌安全部署新功能
- 實施藍綠部署或金絲雀發布策略
- 自動化數據庫遷移
- 建立部署回滾機制
</ci_cd>

<project_management>
- 採用適合團隊的敏捷方法論
- 保持短迭代週期
- 進行定期的敏捷會議
- 使用任務板可視化工作流程
- 實施速度跟踪和燃盡圖
- 優先處理技術債務
- 培養自組織團隊文化
- 實施持續改進流程
</project_management>

<documentation>
- 維護最新的系統架構文檔
- 創建清晰的 API 文檔
- 編寫全面的操作手冊
- 保持用戶文檔與產品功能同步
- 使用知識庫或 wiki 系統組織知識
- 記錄關鍵決策和設計選擇的理由
- 實施文檔審查流程
- 採用「文檔即代碼」方法
</documentation>

<monitoring>
- 實施全面的日誌記錄策略
- 採用集中式日誌管理解決方案
- 設置關鍵性能指標和服務水平目標
- 實施分佈式追踪系統
- 使用指標監控系統健康狀況
- 設置警報系統
- 創建全面的儀表板
- 定期進行事後分析
</monitoring>

<security>
- 遵循安全開發生命週期實踐
- 進行定期的安全審計
- 實施最小權限原則
- 安全地存儲敏感數據
- 實施強大的身份驗證和授權機制
- 遵守相關的法規和標準
- 進行安全意識培訓
- 建立安全事件響應計劃
</security>

<performance>
- 設計可水平擴展的系統架構
- 實施緩存策略
- 優化數據庫查詢和索引
- 使用負載均衡
- 實施異步處理和消息隊列
- 考慮使用 CDN 分發靜態內容
- 實施數據分區和分片策略
- 定期進行性能基準測試
</performance>

<team_collaboration>
- 培養開放的溝通文化
- 實施配對編程和集體代碼所有權
- 組織定期的技術分享會議
- 鼓勵跨職能協作
- 實施導師制度
- 慶祝成功和學習失敗
- 支持工作與生活的平衡
- 定期收集和行動於團隊反饋
</team_collaboration>

<technical_debt>
- 定期識別和記錄技術債務項目
- 為技術債務項目分配優先級
- 在每個迭代中分配時間處理技術債務
- 使用重構改進現有代碼質量
- 建立技術債務預算
- 記錄引入技術債務的決策理由
- 使用代碼質量指標監控技術債務
- 教育利益相關者了解技術債務的影響
</technical_debt>

</software_engineering_best_practices>
